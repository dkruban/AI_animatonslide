<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Cyberpunk Seminar - Ruban.M</title>
    <style>
        /* --- CYBERPUNK STYLES --- */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #050510; /* Deep Dark Blue/Black */
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
            user-select: none;
            -webkit-user-select: none;
        }

        #cinema { display: block; width: 100%; height: 100%; filter: contrast(1.2) brightness(1.2); }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.5) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10;
        }

        #hud {
            position: absolute; bottom: 25%; left: 10%; width: 80%;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5); z-index: 20; pointer-events: none;
        }

        h1 {
            font-size: 3rem; margin: 0; text-transform: uppercase; letter-spacing: 4px;
            background: rgba(0, 0, 0, 0.8); display: inline-block; padding: 0 20px;
            border-left: 8px solid #00ffff; /* Neon Cyan Border */
            font-weight: 800; color: #fff;
            text-shadow: 0 0 15px #00ffff; /* Neon Glow */
        }

        #typewriter {
            font-size: 1.4rem; margin-top: 15px; background: rgba(0, 5, 16, 0.85);
            padding: 20px; min-height: 3.5rem; border-left: 3px solid #ff00ff; /* Pink Border */
            line-height: 1.6; color: #ccc; text-align: left;
        }

        /* CONTROLS */
        #video-controls {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            display: flex; align-items: center; padding: 0 20px; box-sizing: border-box; z-index: 100;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
        }
        #scrubber {
            -webkit-appearance: none; width: 100%; height: 8px; background: #222;
            outline: none; cursor: pointer;
        }
        #scrubber::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; background: #ff00ff;
            cursor: pointer; border-radius: 50%; box-shadow: 0 0 15px #ff00ff;
        }
        #pause-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; color: #ff00ff; border: 5px solid #ff00ff;
            padding: 20px; background: rgba(0,0,0,0.9); display: none;
            z-index: 100; pointer-events: none; font-weight: bold;
        }
        #slide-counter {
            position: absolute; top: 20px; right: 20px; font-family: monospace; color: #00ffff; z-index: 20;
            font-weight: bold;
        }
        #voice-btn {
            position: fixed; bottom: 40px; right: 40px; z-index: 150;
            background: #222; border: 2px solid #00ffff; color: #fff;
            width: 60px; height: 60px; border-radius: 50%; cursor: pointer;
            font-size: 24px; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 15px rgba(0,255,255,0.3); transition: 0.3s;
        }
        #voice-btn.active { background: #00ffff; color: #000; box-shadow: 0 0 25px #00ffff; }
        #voice-btn:hover { transform: scale(1.1); }
    </style>
</head>
<body>

    <div id="overlay"></div>
    <canvas id="cinema"></canvas>
    <div id="pause-indicator">PAUSED</div>
    <div id="slide-counter">01 / 45</div>
    <button id="voice-btn" onclick="toggleVoice()" title="Toggle Voice">ðŸ”‡</button>
    
    <div id="hud">
        <h1 id="slide-title">INIT</h1>
        <div id="typewriter"></div>
    </div>
    
    <div id="video-controls">
        <input type="range" min="0" max="100" value="0" step="0.1" id="scrubber">
    </div>

    <script>
        // --- AI SEMINAR CONTENT (Same text, new visuals) ---
        const scenes = [
            // --- INTRO ---
            { t: "The Presentation by", s: "Ruban.M", e: "cyber_city", duration: 600 },
            { t: "Topic: Artificial Intelligence", s: "A Deep Dive into Neural Networks, Robotics, and the Future.", e: "grid", duration: 400 },
            { t: "What is AI?", s: "AI is the simulation of human intelligence processes by machines, especially computer systems.", e: "circuit", duration: 400 },
            
            // --- HISTORY ---
            { t: "1950: The Turing Test", s: "Alan Turing proposed a test to determine if a machine can exhibit intelligent behavior.", e: "hologram", duration: 400 },
            { t: "1956: Dartmouth Workshop", s: "The term 'Artificial Intelligence' was first coined at this academic conference.", e: "timeline", duration: 400 },
            { t: "1997: Deep Blue", s: "IBM's computer defeated the reigning world chess champion, Garry Kasparov.", e: "scan_face", duration: 400 },
            { t: "2012-Now: Deep Learning", s: "Neural networks using big data started beating humans at complex tasks.", e: "drones", duration: 400 },

            // --- ARCHITECTURE ---
            { t: "Neural Networks", s: "Systems modeled after the human brain. They learn patterns by processing vast amounts of data.", e: "brain", duration: 400 },
            { t: "Machine Learning", s: "Instead of explicit programming, AI improves its own performance over time with experience.", e: "scan_face", duration: 400 },
            { t: "Generative AI", s: "AI that can create new content, like images, text, or code (e.g., ChatGPT).", e: "hologram", duration: 400 },
            
            // --- CAPABILITIES ---
            { t: "Computer Vision", s: "AI can analyze images and videos to identify objects, faces, and emotions.", e: "scan_face", duration: 400 },
            { t: "Natural Language", s: "Machines understand and generate human language with high accuracy.", e: "hologram", duration: 400 },
            { t: "Robotics", s: "Physical bodies for AI to interact with the real world, like Boston Dynamics.", e: "drones", duration: 400 },

            // --- RISKS & ETHICS ---
            { t: "Risk 1: Deepfakes", s: "AI can create realistic fake videos and audio to manipulate public opinion.", e: "glitch", duration: 500 },
            { t: "Risk 2: Job Displacement", s: "Automation threatens jobs in manufacturing, customer service, and driving.", e: "cyber_city", duration: 500 },
            { t: "Risk 3: Algorithmic Bias", s: "AI learns from human data, so it can inherit our prejudices and racism.", e: "scan_face", duration: 500 },
            { t: "Risk 4: The Black Box", s: "We don't always know HOW AI reaches a decision, just that it did.", e: "circuit", duration: 500 },

            // --- THE FUTURE ---
            { t: "The Singularity", s: "A hypothetical point where AI becomes smarter than humans, changing the world forever.", e: "grid", duration: 500 },
            { t: "AI in Healthcare", s: "Diagnosing diseases faster than doctors and discovering new drugs.", e: "scan_face", duration: 400 },
            { t: "AI in Warfare", s: "Autonomous drones and cyber-weapons changing the battlefield.", e: "drones", duration: 400 },
            { t: "Transhumanism", s: "Merging human biology with machine intelligence to enhance capabilities.", e: "brain", duration: 500 },

            // --- CONCLUSION ---
            { t: "Summary", s: "AI is a tool that can save or destroy us. We must guide it with ethics.", e: "grid", duration: 500 },
            { t: "Thank You", s: "Questions? - Presented by Ruban.M", e: "loader", duration: 600 }
        ];

        // --- ENGINE STATE ---
        const canvas = document.getElementById('cinema');
        const ctx = canvas.getContext('2d');
        let width, height, time = 0;
        let slideIdx = 0, autoPlay = true, lastChange = 0, voiceEnabled = false;
        
        let targetText = "", currentText = "", charIdx = 0;
        
        // Animation Data Containers
        let particles = [], buildings = [], drones = [];
        
        // --- INIT ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            canvas.addEventListener('touchstart', togglePause);
            canvas.addEventListener('click', togglePause);
            document.addEventListener('keydown', (e) => { if(e.code==='Space') togglePause(); });

            const scrubber = document.getElementById('scrubber');
            scrubber.addEventListener('mousedown', () => { autoPlay = false; });
            scrubber.addEventListener('touchstart', () => { autoPlay = false; });
            scrubber.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                slideIdx = Math.floor((val / 100) * scenes.length);
                if(slideIdx >= scenes.length) slideIdx = scenes.length - 1;
                loadSlide(slideIdx, true);
            });

            // Init Data
            initCity();
            initDrones();

            loop();
            loadSlide(0);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function togglePause() {
            autoPlay = !autoPlay;
            document.getElementById('pause-indicator').style.display = autoPlay ? 'none' : 'block';
            if(autoPlay) window.speechSynthesis.resume();
            else window.speechSynthesis.pause();
        }

        function toggleVoice() {
            voiceEnabled = !voiceEnabled;
            const btn = document.getElementById('voice-btn');
            if(voiceEnabled) {
                btn.classList.add('active'); btn.innerHTML = 'ðŸ”Š';
                speakText(scenes[slideIdx].s);
            } else {
                btn.classList.remove('active'); btn.innerHTML = 'ðŸ”‡';
                window.speechSynthesis.cancel();
            }
        }

        function speakText(text) {
            if(!voiceEnabled) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1;
            const voices = window.speechSynthesis.getVoices();
            const engVoice = voices.find(v => v.lang.includes('en'));
            if(engVoice) utterance.voice = engVoice;
            window.speechSynthesis.speak(utterance);
        }

        function loadSlide(idx, instant = false) {
            slideIdx = idx;
            const s = scenes[slideIdx];
            document.getElementById('slide-title').innerText = s.t;
            document.getElementById('slide-counter').innerText = `${(idx+1).toString().padStart(2,'0')} / ${scenes.length}`;
            targetText = s.s;
            
            if(instant) {
                currentText = targetText;
                document.getElementById('typewriter').innerText = currentText;
                charIdx = targetText.length;
            } else {
                charIdx = 0; currentText = "";
            }

            if(voiceEnabled && !instant) speakText(s.s);
            document.getElementById('scrubber').value = ((slideIdx) / scenes.length) * 100;
            lastChange = time;
            ctx.fillStyle = '#050510'; ctx.fillRect(0,0,width,height);
        }

        // --- ANIMATION INITIALIZERS ---
        function initCity() {
            buildings = [];
            let bWidth = 50;
            for(let i=0; i<width/bWidth; i++) {
                buildings.push({
                    h: Math.random() * 300 + 50,
                    w: bWidth,
                    x: i * bWidth,
                    windows: []
                });
                // Generate windows
                for(let j=0; j<10; j++) {
                    if(Math.random()>0.5) buildings[i].windows.push(j);
                }
            }
        }
        function initDrones() {
            drones = [];
            for(let i=0; i<5; i++) {
                drones.push({ x: Math.random()*width, y: Math.random()*height, v: 5+Math.random()*5 });
            }
        }

        // --- THE RENDER ENGINES (CYBERPUNK THEME) ---
        const engines = {
            // 1. CYBER CITY (Neon Skyscrapers)
            cyber_city: () => {
                // Buildings
                buildings.forEach(b => {
                    ctx.fillStyle = '#0a0a20';
                    ctx.fillRect(b.x, height - b.h, b.w, b.h);
                    
                    // Neon Edges
                    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 1;
                    ctx.strokeRect(b.x, height - b.h, b.w, b.h);

                    // Windows
                    b.windows.forEach(w => {
                        ctx.fillStyle = '#ff00ff'; // Pink Neon
                        ctx.fillRect(b.x + 5, height - b.h + 10 + w*25, b.w - 10, 15);
                    });
                });
            },

            // 2. GRID (Tron Floor)
            grid: () => {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                const gridSize = 50;
                const offset = (time * 2) % gridSize;
                
                // Vertical lines
                for(let x=0; x<width; x+=gridSize) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                }
                // Horizontal moving lines
                for(let y=offset; y<height; y+=gridSize) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
                }
            },

            // 3. HOLOGRAM (Flickering Figure)
            hologram: () => {
                const cx = width/2, cy = height/2;
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
                if(Math.random()>0.9) ctx.strokeStyle = '#fff'; // Glitch flicker
                
                // Head
                ctx.beginPath(); ctx.arc(cx, cy-50, 30, 0, Math.PI*2); ctx.stroke();
                // Body
                ctx.beginPath(); ctx.moveTo(cx, cy-20); ctx.lineTo(cx, cy+50); ctx.stroke();
                // Arms
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx-40, cy+30); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+40, cy+30); ctx.stroke();
                
                // Data particles
                ctx.fillStyle = '#ff00ff';
                for(let i=0; i<10; i++) {
                    let py = cy - 50 + (time + i*10) % 100;
                    ctx.fillRect(cx - 20 + Math.random()*40, py, 2, 2);
                }
            },

            // 4. CIRCUIT (90-degree lines)
            circuit: () => {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
                for(let i=0; i<20; i++) {
                    let x = (time * 5 + i * 100) % width;
                    let y = Math.random() * height;
                    ctx.beginPath();
                    ctx.moveTo(x, y); ctx.lineTo(x + 20, y); ctx.lineTo(x + 20, y + (Math.random() > 0.5 ? 20 : -20));
                    ctx.stroke();
                    
                    // Node
                    ctx.fillStyle = '#ff00ff'; ctx.beginPath(); ctx.arc(x+20, y + (Math.random() > 0.5 ? 20 : -20), 3, 0, Math.PI*2); ctx.fill();
                }
            },

            // 5. SCANNING FACE (Grid over head)
            scan_face: () => {
                const cx = width/2, cy = height/2;
                
                // Head Outline
                ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx, cy-70); ctx.lineTo(cx+30, cy-70); ctx.lineTo(cx+40, cy-60); ctx.lineTo(cx+40, cy+20); ctx.lineTo(cx+20, cy+50); ctx.lineTo(cx-20, cy+50); ctx.lineTo(cx-40, cy+20); ctx.lineTo(cx-40, cy-60); ctx.lineTo(cx-30, cy-70); ctx.closePath(); ctx.stroke();

                // Grid
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                for(let i=-40; i<40; i+=10) {
                    ctx.beginPath(); ctx.moveTo(cx+i, cy-70); ctx.lineTo(cx+i, cy+50); ctx.stroke();
                }
                
                // Scanning Line
                const scanY = ((time*3) % 120) - 70;
                ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(cx-50, cy+scanY); ctx.lineTo(cx+50, cy+scanY); ctx.stroke();
            },

            // 6. DRONES (Triangles)
            drones: () => {
                ctx.fillStyle = '#00ffff';
                drones.forEach(d => {
                    d.x += d.v;
                    if(d.x > width) d.x = -50;
                    
                    // Triangle
                    ctx.beginPath(); 
                    ctx.moveTo(d.x, d.y); 
                    ctx.lineTo(d.x-20, d.y+10); 
                    ctx.lineTo(d.x-20, d.y-10); 
                    ctx.closePath(); ctx.fill();
                    
                    // Trail
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(d.x-50, d.y); ctx.stroke();
                });
            },

            // 7. BRAIN (Neon Dots)
            brain: () => {
                const cx = width/2, cy = height/2;
                ctx.fillStyle = '#ff00ff';
                for(let i=0; i<100; i++) {
                    // Random blob shape
                    let r = 120 + Math.sin(time*0.05 + i)*10;
                    let a = (i / 100) * Math.PI * 2;
                    let x = cx + r * Math.cos(a);
                    let y = cy + r * Math.sin(a) * 0.8; // Slightly oval
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
                    
                    // Connect to center
                    if(Math.random()>0.9) {
                        ctx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
                        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x, y); ctx.stroke();
                    }
                }
            },

            // 8. TIMELINE (Neon Line)
            timeline: () => {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(50, height/2); ctx.lineTo(width-50, height/2); ctx.stroke();
                const spacing = (width-100) / 12;
                for(let i=0; i<12; i++) {
                    ctx.fillStyle = '#ff00ff'; ctx.beginPath(); ctx.arc(50 + i*spacing, height/2, 8, 0, Math.PI*2); ctx.fill();
                    // Glow effect for active
                    if(i === Math.floor((time/10)%12)) {
                        ctx.shadowBlur = 20; ctx.shadowColor = '#ff00ff';
                        ctx.beginPath(); ctx.arc(50 + i*spacing, height/2, 15, 0, Math.PI*2); ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
            },

            // 9. GLITCH (Neon Bars)
            glitch: () => {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                for(let i=0; i<10; i++) {
                    if(Math.random()>0.5) ctx.fillRect(Math.random()*width, Math.random()*height, Math.random()*200, 5);
                }
                ctx.font = '40px monospace'; ctx.fillStyle = '#ff00ff';
                if(Math.random()>0.9) ctx.fillText("SYSTEM ERROR", width/2 - 100, height/2);
            },

            // 10. LOADER (Cyan Circle)
            loader: () => {
                const cx = width/2, cy = height/2; 
                ctx.lineWidth = 8; ctx.strokeStyle = '#00ffff'; ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
                ctx.beginPath(); ctx.arc(cx, cy, 60, time*0.1, time*0.1 + Math.PI); ctx.stroke();
                ctx.shadowBlur = 0;
            }
        };

        // --- LOOP ---
        function loop() {
            requestAnimationFrame(loop); time++;
            if(autoPlay) {
                const currentDuration = scenes[slideIdx].duration || 400;
                if(time - lastChange > currentDuration) {
                    if(slideIdx < scenes.length-1) loadSlide(slideIdx+1);
                    else autoPlay = false;
                }
            }
            if(autoPlay && charIdx < targetText.length && time%3===0) {
                currentText += targetText[charIdx++];
                document.getElementById('typewriter').innerText = currentText;
            }
            ctx.fillStyle = 'rgba(5, 5, 16, 0.3)'; // Fade trails (Cyberpunk feel)
            ctx.fillRect(0,0,width,height);
            const engineKey = scenes[slideIdx].e;
            if(engines[engineKey]) engines[engineKey]();
        }

        // Start
        init();
    </script>
</body>
</html>
